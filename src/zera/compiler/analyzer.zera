; vim: ft=clojure
(require "syntax.zera")
(ns zera.compiler.analyzer)

(alias 's 'zera.compiler.syntax)

(def property-accessor? isPropertyAccessor)
(def property-assignment? isPropertyAssignment)
(def method-application? isMethodApplication)
(def class-instantiation? isClassInstantiation)

(def variable? symbol?)

(defn tag-predicate [tag]
  (lambda [exp] (= tag (first exp))))

(def quoted? (tag-predicate 'quote))

(def definition? (tag-predicate 'def))

(def if? (tag-predicate 'if))

(def lambda? (tag-predicate 'fn))

(def block? (tag-predicate 'do))

(def assignment? (tag-predicate 'set!))

(def variable-introspection? (tag-predicate 'defined?))

(def thrown-exception? (tag-predicate 'throw))

(def application? list?)

(defn analyze-application [fn &args]
  (s/Application. fn args))

(defn analyze-nil
  [x]
  (s/Nil.))

(defn analyze-number
  [x]
  (s/Number. x))

(defn analyze-boolean
  [x]
  (s/Boolean. x))

(defn analyze-string
  [x]
  (s/String. x))

(defn analyze-date
  [x]
  (s/Instant. x))

(defn analyze-regexp
  [x]
  (s/RegExp. x))

(defn analyze-keyword
  [x]
  (s/Keyword. (namespace x) (name x)))

(defn analyze-symbol
  [x]
  (s/Symbol. (namespace x) (name x)))

(defn analyze-map-entries
  [x]
  [(analyze (x 0)) (analyze (x 1))])

(defn analyze-map
  [x]
  (s/Map. (map analyze-map-entries x)))

(defn analyze-vector
  [x]
  (s/Vector. (map analyze x)))

(defn analyze-set
  [x]
  (s/Set. (map analyze x)))

(defn analyze-variable
  [x]
  (s/Variable. (namespace x) (name x)))

(defn analyze-quoted
  [x]
  (s/QuotedValue. (analyze x)))

(defn analyze-definition
  ([nm] (s/Definition. (s/Variable. (namespace nm) (name nm)) nil (hash-map)))
  ([nm value] (s/Definition. (s/Variable. (namespace nm) (name nm)) value (hash-map)))
  ([nm value meta] (s/Definition. (s/Variable. (namespace nm) (name nm)) value meta)))

(defn analyze-if
  ([pred alt]
   (s/If. (analyze pred) (analyze alt) nil))
  ([pred alt conse]
   (s/If. (analyze pred) (analyze alt) (analyze conse))))

(defn analyze-lambda
  [args]
  (let [x (first args)]
    (cond
      (vector? x) (s/Lambda. 1 (list (analyze-argument-vector x)) (list (map analyze (rest args))))
      (list? x)
        (let [arglists (map analyze (map first args))
              argcount (argument-count arglists)]
          (s/Lambda.
            argcount
            arglists
            (map analyze (map second args))))
        :else
          (throw (js/Error. "the second element of a Lambda expression should be an arguments vector or a list of bodies")))))

(defn argument-count
  [arglists]
  (->> arglists
       (map count)
       sort
       first))

(defn analyze-argument-vector
  [args]
  (s/ArgumentVector. (map analyze args)))

(defn analyze-block
  [body]
  (s/Block. body))

(defn analyze-thrown-exception
  [expression]
  (s/ThrownException. expression))

(defn analyze-property-accessor
  [obj property]
  (s/PropertyAccessor. obj property))

(defn analyze-property-assignment
  [obj property value]
  (s/PropertyAssignment. obj property value))

(defn analyze-method-application
  [obj method args]
  (s/MethodApplication. obj method args))

(defn analyze-class-instantiation
  [class args]
  (s/ClassInstatiation. class args))

(defn analyze-application
  [fn args]
  (s/Application. fn args))

(defn analyze [exp]
  (let [exp_ (macroexpand exp)]
    (cond (nil? exp) (analyze-nil exp)
          (number? exp) (analyze-number exp)
          (boolean? exp) (analyze-boolean exp)
          (string? exp) (analyze-string exp)
          (date? exp) (analyze-date exp)
          (regexp? exp) (analyze-regexp exp)
          (keyword? exp) (analyze-keyword exp)
          (map? exp) (analyze-map exp)
          (vector? exp) (analyze-vector exp)
          (set? exp) (analyze-set exp)
          (variable? exp) (analyze-variable exp)
          (quoted? exp) (apply analyze-quoted (rest exp))
          (definition? exp) (apply analyze-definition (rest exp))
          (if? exp) (apply analyze-if (rest exp))
          (lambda? exp) (analyze-lambda (rest exp))
          (block? exp) (apply analyze-block (rest exp))
          (assignment? exp) (apply analyze-assignment (rest exp))
          (thrown-exception? exp) (apply analyze-thrown-exception (rest exp))
          (property-accessor? exp) (apply analyze-property-accessor (rest exp))
          (property-assignment? exp) (apply analyze-property-assignment (rest exp))
          (method-application? exp) (apply analyze-method-application (rest exp))
          (class-instantiation? exp) (apply analyze-class-instantiation (rest exp))
          (application? exp) (apply analyze-application exp)
          :else 
            (do
              (println exp)
              (throw (str "analyz: invalid form: '" exp "'"))))))
